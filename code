#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef struct {
    int n;
    int k;
} Keys;

typedef struct {
    int x;
    unsigned long long value; // Use unsigned long long for larger values
} Root;

// Function to convert a number from a given base to decimal
unsigned long long decodeValue(int base, const char *value) {
    unsigned long long decimalValue = 0;
    unsigned long long basePower = 1; // base^0

    // Process the value string in reverse to handle positional values
    for (int i = strlen(value) - 1; i >= 0; i--) {
        char digit = value[i];
        int digitValue;

        // Convert character to corresponding integer value
        if (digit >= '0' && digit <= '9') {
            digitValue = digit - '0';
        } else if (digit >= 'a' && digit <= 'f') {
            digitValue = digit - 'a' + 10;
        } else {
            digitValue = digit - 'A' + 10; // For uppercase letters
        }

        decimalValue += digitValue * basePower;
        basePower *= base; // Increase base power
    }

    return decimalValue;
}

// Extracting keys "n" and "k" from the JSON-like data
Keys extractKeys(const char *jsonData) {
    Keys keys = {0, 0};
    char *nPos = strstr(jsonData, "\"n\": ");
    char *kPos = strstr(jsonData, "\"k\": ");
    if (nPos && kPos) {
        sscanf(nPos, "\"n\": %d", &keys.n);
        sscanf(kPos, "\"k\": %d", &keys.k);
    }
    return keys;
}

// Extracting roots from the JSON-like data
int extractRoots(const char *jsonData, Root *roots, int maxRoots) {
    int count = 0;
    char *data = strstr(jsonData, "\"1\":");
    while (data && count < maxRoots) {
        int x, base;
        char value[64]; // Buffer for value strings
        sscanf(data, "\"%d\": {\n        \"base\": \"%d\",\n        \"value\": \"%s",
               &x, &base, value);
        roots[count].x = x;
        roots[count].value = decodeValue(base, value);
        count++;
        data = strstr(data + 1, "\"");
    }
    return count;
}

// Lagrange interpolation calculation
unsigned long long calculateLagrangeInterpolation(Root *roots, int count, int k) {
    unsigned long long result = 0;
    for (int i = 0; i < k; i++) {
        unsigned long long term = roots[i].value;
        for (int j = 0; j < k; j++) {
            if (i != j) {
                term *= -roots[j].x;
                term /= (roots[i].x - roots[j].x);
            }
        }
        result += term;
    }
    return result;
}

int main() {
    // Simulating JSON data as a string
    const char *jsonData = "{\n"
                           "    \"keys\": {\n"
                           "        \"n\": 10,\n"
                           "        \"k\": 7\n"
                           "    },\n"
                           "    \"1\": {\n"
                           "        \"base\": \"6\",\n"
                           "        \"value\": \"13444211440455345511\"\n"
                           "    },\n"
                           "    \"2\": {\n"
                           "        \"base\": \"15\",\n"
                           "        \"value\": \"aed7015a346d63\"\n"
                           "    },\n"
                           "    \"3\": {\n"
                           "        \"base\": \"15\",\n"
                           "        \"value\": \"6aeeb69631c227c\"\n"
                           "    },\n"
                           "    \"4\": {\n"
                           "        \"base\": \"16\",\n"
                           "        \"value\": \"e1b5e05623d881f\"\n"
                           "    },\n"
                           "    \"5\": {\n"
                           "        \"base\": \"8\",\n"
                           "        \"value\": \"316034514573652620673\"\n"
                           "    },\n"
                           "    \"6\": {\n"
                           "        \"base\": \"3\",\n"
                           "        \"value\": \"2122212201122002221120200210011020220200\"\n"
                           "    },\n"
                           "    \"7\": {\n"
                           "        \"base\": \"3\",\n"
                           "        \"value\": \"20120221122211000100210021102001201112121\"\n"
                           "    },\n"
                           "    \"8\": {\n"
                           "        \"base\": \"6\",\n"
                           "        \"value\": \"20220554335330240002224253\"\n"
                           "    },\n"
                           "    \"9\": {\n"
                           "        \"base\": \"12\",\n"
                           "        \"value\": \"45153788322a1255483\"\n"
                           "    },\n"
                           "    \"10\": {\n"
                           "        \"base\": \"7\",\n"
                           "        \"value\": \"1101613130313526312514143\"\n"
                           "    }\n"
                           "}";

    Keys keys = extractKeys(jsonData);
    Root roots[10];
    int count = extractRoots(jsonData, roots, keys.n);

    // Ensure we have enough points (at least k)
    if (count >= keys.k) {
        // Solve for the constant term c using Lagrange interpolation
        unsigned long long secret = calculateLagrangeInterpolation(roots, count, keys.k);
        printf("The secret constant term (c) is: %llu\n", secret);
    } else {
        printf("Insufficient points to solve for the polynomial.\n");
    }

    return 0;
}
